---
title: "[GO]用go语言实现lru缓存"
date: 2020-02-19T14:07:36+08:00
draft: true
---
lru缓存，在当今依然非常热门的面试问题，笔者曾经面试【某蜓，音频领域的top公司】就问到了这个问题，当时回答的并不是好。那我们一起来看看如何从0-1实现一个完美的lru缓存。
<!--more-->


## 简介
缓存，在日常的使用中帮助我们降低接口的响应速度，常常是将一些数据加载到**内存**当中，调用方的请求进来之后服务可以直接从内存中拿到数据，然后直接返回，减少了代码里面的逻辑处理，如果有数据查询，或者网络调用的话，这些步骤都可以省去，这些时间是非常可观的。所以非时间敏感的数据是可以加载到内存中去的，但是主机的资源是有限的，这其中内存资源尤其的紧张，所以缓存策略会**限制使用的内存大小**，当缓存满了之后，新进来的元素就需要踢掉旧有的某个元素，这就涉及到**缓存淘汰**。



## 缓存淘汰算法介绍
#### FIFO(first input first output)
先进先出，符合人的直观感受，当超过设定的内之后淘汰掉最先进来的元素，如何设计这种数据结构，很容易联想起数组【array】和队列【Queue】，

#### 数组的实现
当然这是很不灵活的方法，但是将其写下来，再跟其他方式对比，才能更加深入肌理。使用go的数组实现FIFO不复杂，但是淘汰e1的时候，数组中的元素需要往后移动，e2占了A[0]的位置，e3占了A[1]的位置，以此类推，直到空出的位置插入e6。

![image](/img/FIFO-flow-chart.png)

##### 队列的实现
简单的话,使用golang的`container/list`包双向链表，不考虑时间的话，可以自己实现一个单链表，满足fifo的要求。

如图所示：
![image](/img/single-list.jpg)

链表的好处在于，删除头部元素以及插入尾部元素的时间复杂度都是O(1), 相较于array紧密的内存分布，list是通过指针相连，内存较为分散。但是array需要遍历才能移动元素，最终才能插入一个数据的方式，如果数量较大的情况下，计算的时间非常可观，所以使用list是优于array的。

#### LFU


####  LRU

#### LRU-K


## 经典使用场景列举


## 总结







