---
title: "Operating system read notes"
date: 2020-07-11T09:33:34+08:00
draft: true
---

我总有很多问题，这些问题在不解决之前，总有一天他们会相遇在同一个地方，然后成为一个「大麻烦」，最近看「章老师说」，真正的SE「soft engineer」从30岁开始都算晚。所以我将读操作系统的一些要点记录下来，里面也许会回答一些我们在使用电脑过程中遇到的常见的问题。另外此书也不是一蹴而就，需要经常翻阅。notes的记录线会跟随章节来走。



# 基础原理

为什么要学操作系统
* as you will 「智者的故事，一只在别人背后的鸟，它的生死跟随这个人的意志转移」

现实世界的事物分为两类
* 已经存在的
* 人造的

计算机属于人造的事物，人造的事物具有如下的特定
* 不精确，具有相对性「没有绝对的好坏/对错」
* 从对人类活动的观察导出 「比如排队，约会等」
* 依赖于人的主观判断力
* 通常符合人的直觉


操作系统的范畴
* cpu管理
* 内存管理
* 外存管理
* I/O管理

# 操作系统的历史

sometimes when we touch, the honest is too much.
当我们拥抱的时候，我才感受到真实，这句话非常的切合我们需要对历史的了解的必要性。

操作系统的发展历程
* sosc 「single operation single console」 单人单控制
* 批处理系统
* 多道系统
* 分时系统
* 实时系统
* 商业系统/个人系统/服务器系统

实际的历程比这个要复杂，这几个历程是总体是比较关键点节点，这样符合人的直觉和持续迭代的事实。比如一开始的计算机是只能一个人控制，并且由复杂的装载程序和打印程序，那个时代计算机非常的昂贵，这种资源的浪费是非常不值得，批处理系统就是可以一次性再装载完整个程序之后可以一次执行，但是人是多线程的，我们自然想计算机是否可以同时执行多个程序，这就是多道技术的出现原因，在单核时代本质上还是执行一个程序，只是感觉上执行了多个程序。但是这种方式只解决了多个程序同时执行的问题，人们有想，我是否可以多个人，在不同的时间「提前预定的时间」也能执行我自己的程序，这就是分时系统的出现「我们现在使用的多数都是分时系统」，real time系统主要是用在特定的场合，它实时的含义是，在可预测的时间之内完成计算，不然就失去了计算的意义，打个不好的比方，比如我使用滴滴打车去赶火车，如果滴滴告诉我需要30min才能到达目的地，但是这样我可能就迟到了，那我使用滴滴还有什么意义呢？ 当然假如我的预期是20min之内，那么只要有系统能做到，那么它就是我认为的实时的，这也就是说计算机的定义是相对的，不是绝对的，它的本质依然是管理有限资源的使用并且保证它们的效率和安全。


# 操作系统的基本概念
* 总线，各种设备挂载在总线上面
* 硬件指令流水线
* 指令存储单元，寄存器--》缓存--》内存--》磁盘--》磁带，执行时间1nsec---》2nsec--》10nsec--》10msec--》100sec
* 用户态和内核态，区分这两个态在于cpu中的状态位，内核态具有对底层资源访问的最高权限，用户态相对来说掌握的资源有限，另外用户态也可以转换成内核态，反之亦然，但是这种切换代价是很大的。
* 操作系统的结构，早起是网络结构，容易造成循环调用和死锁，后期发展成模块化和分层。
* 微内核，为了应对内核代码过多提出的概念，也就是内核的内核才放在内核态中。
* 进程，内存，文件
* 系统调用，入c语言的resutl = read(fd, buffer, nbytes), 最终会调用内核中的read函数，并且返回结果。
* 系统调用的参数通过压栈的方式推进，但是这也不全是，也有系统是通过寄存器来传递，如上，我们知道寄存器的速度快于内存。
* 没有编程语言咋办，操作系统提供一个壳，最常见的就是shell或者powershell。
* 系统调用如何执行，fork并且execave
* 进程的出现是人们对并发的渴望，进程模型也是计算机对cpu控制的体现。

# 进程（process）

* 一个程序加载到内存后就变为进程，即； 进程=程序+执行

## 进程模型
* 物理上，同一时刻，cpu只能执行一条命令，所以所有进程共用一个程序计数器
* 逻辑上，每个进程都觉得自己的执行，但是实际是有的进程在等待io而让出cpu控制权，所以这就需要每个进程记住自己的执行的位置，这样计数器就有多个了。
* 进程是程序需要分配在物理内存之上，但是资源是有限的，多个进程之间如何解决内存竞争问题？
* 进程需要调度，也就是谁可以执行的问题？

## 进程模型的好处
* 提高cpu的使用效率
* 计算方式，假设一个程序20%的时间使用cpu，80%的时间在进行I/O，那么cpu的使用率只有20%。 1-80% = 20%。 如果是两个这样的程序呢，只有两边都在进行IO操作，cpu才被浪费，也就是 1- 80%*80% = 36%的利用率。
* 我们称同时执行的程序个数为度，系统cpu的利用率会随着度的提高而提高，但是后面甚至不会提高，还会下降，因为系统之间的切换将消耗大量的资源。
* 影响时间改善

## 进程的产生和消亡

产生
* 系统初始化 （神创造人）
* 执行进程创立程序 （人生子）
* 用户请求创立新进程 （试管婴儿）

消亡
* 寿终：进程运行完成而退出。
* 自杀：进程因错误而自行退出。
* 他杀：进程被其他进程所终止。
* 处决：进程因异常而被强行终结。

## 进程的结构

* unix是进程tree的概念
* window是平等的结构

## 进程的执行状态 「并非三种」

* 执行态
* 就绪态
* 阻塞态

## 进程与地址空间
进程和地址空间最好的比喻

舞台剧，舞台是不会动的，但是它是演员发挥的空间，那么；
* 舞台是地址空间
* 演员就是一个一个线程
* 多数线程是用户态的

## 进程管理

就像人一样，我们从出生还有就有各种证明，男/女，身高，年纪
那么进程也需要，称之为pcb「process control block」

## 进程的缺点
* 进程同一时刻，只能做一件事，做不了两件事。
* 如果进程里的部分发生了blocking，但是其他部分依然可以执行，也无法办到。

# 进程调度

程序分类
* cpu密集型
* IO密集型
* 两者之间

目标
* 平均响应时间较小
* 提高系统吞吐率
* 各个进程能相对公平的执行

先到先服务的调度算法FCFS「first come first server」.

优点：简单
缺点：耗时较长的进程会阻碍耗时非常短的进程。

时间片轮转调度算法
简单的说，就是选择一个时间段，各个进程各自执行这些时间，然后退出来让后面的执行

重点： 时间片时间的选择，多少才合适呢？

短任务优先算法STCF「shorted time to completion first」

优先级的概念出现，短任务优先于长任务。

两种两种
* 非抢占式
* 抢占式

优点：提高了响应时间
缺点：可能导致进程“饥饿”

依赖程序的执行时间来判断长短，如何判断

* 经验？❌
* 先执行一遍 ✅

优先级调度算法
stcf算法算是一种优先级算法，但是只针对短任务，优先级算法会给所有的进程一个优先级。

混合调度算法

先分优先级，优先级再按照时间轮片； 优先级算法+时间轮片


# 进程通信

通信是基本需求，进程也不例外，进程间通信称为； inter_process_communication, short for: IPC

管道
* 在unix使用|表示
* 丰富的语意
* 需要建立进程之间的管道/套接字
* 建立连接是耗时的
* 必须是同处同一台物理机

信号signal

适用场景
* 想迫使对方对我们的通信立即做出回应。
* 我们不想事先建立任何连接。
* 传输的信息量很少

如何发送信号
* 发送方将数据组装好，发送给内核+中断。
* 操作系统通过特定中断知道是要发送信号，找到目标进程。
* 接到信号的进程，则对信号进行相应的处理。

信号量「semaphore」

信号量非常的简单，就是一个整数，一个进程在信号变成0或者1的情况下推进。
信号量更像是一种协调，或者同步，而不是沟通或者通信。


超大数据共享怎么办？

共享内存
* 前面的管道，套接字，信号，信号量虽然很好，但是无法满足大数据的通信。
* 全局变量不是共享内存
* 特点是访问随机

消息队列
* 任何进程都可以读写
* 主流的操作系统都做了支持


# 进程的分身术--线程

天下武功，唯快不破。

* 线程是进程的可执行单元，舞台上的每一个演员可以看作是一个线程
* 线程依赖于多核cpu
* 一个进程可以有很多个线程

## 线程的管理

* 共享进程资源
* 但是寄存器，程序计数器，也就是线程上下文是不同的

## 线程的实现

内核态的实现
* 基本被抛弃，消耗太大
* 从用户态陷入内核成本大
* 占用内核宝贵的内存空间
* 谁愿意在那么重要的内核代码上给你改线程的实现？

现代操作系统的混合态的实现
* 阻塞的操纵由内核态来调度
* 非阻塞的线程由用户态来执行
* 并且使用多路复用的方式对应内核的线程

## 多线程的关系

两个贯穿资源管理的问题

* 多个使用者如何同步「这里是线程」
* 多个使用者之间如何通信
* 多线程带来好处和坏处。


# 线程同步

为什么需要同步的原因

* 线程之间的变量是全局变量
* 线程的执行顺序是无法预估的

目的
* 不管线程执行的顺序如何的穿插，依然保证最后的结果是正确的
* 尽力少的对线程加以限制条件

具体表现

* 多线程之间访问了相同的代码段或者相同的资源，这称之为；临界区「critical section」
```
if (no feed) {
    feed fish
}
```

如何解决

## 变形虫

互斥「mutual exclusion」
* 数据或者代码段只能有一个线程占有

互斥满足的条件
* 不能两个线程同时进入临界区
* 线程能够在任何数量和速度的cpu上正确执行
* 在互斥区外不能阻止其他线程推进
* 线程不能无限制的等待进入临界区

留纸条的同步方式，有一点效果，但是在两个线程严格按照执行顺序的话，依然会有问题。

金鱼的喂养问题，本质上线程之间的执行的顺序是无法预料的，这种无法预料会带来车祸一般的问题。

redis使用单线程模式「不使用多线程技术」，也有这样的考虑，好管理，好debug，另外一点就是redis是基于内存操作的，他的瓶颈不在于并发，而是io。

## 鱼的阶段，这个名字起的意思是是说，从变形虫变成鱼，但是好像也没有什么意思哈！

这个阶段要尝解决留纸条带来的问题。我们可以预料到在变形虫阶段，两个人留的纸条，对方是可能看不到的，看不到就会导致两个人去喂鱼，导致金鱼饿死。

那我们就在上面喂鱼之后留纸条的方式，改成先留纸条，再喂鱼，但是这可能造成两边都看不到纸条，从而导致无人喂鱼的问题，【进程饥饿】。

这个结果好像比撑死要好一点，如果把金鱼类比成计算机的资源，那么这种情况下不会耗尽计算机的资源。

## 鱼还是不够智能，让有智能的猴子来试试【循环等待】

鱼的阶段的核心问题就是：对方只认纸条，有没有喂鱼他们不关心，那么我们只要解决双方怎么知道对方喂鱼没有。

* 双方留纸条。
* 对方留纸条，则循环等待【假设a来做这件事】。
* 假设b发现a留了纸条，则不喂鱼，移除纸条
* a发现b的纸条移除，a开始喂鱼

这样就解决了上面，双方都留了纸条，但是因为多线程的穿插原因，导致的无人去喂鱼的问题。

但是上面也会有问题，就是a和b的代码是不一样的，并且也没有复用的可能。


## 锁的诞生

我觉得这个还是比较有意思的，找出一种比较美的锁的实现

* 变形虫，代码简单，一致，但是无法解决执行顺序的问题
* 跟变形虫差不多，代码复杂一些，但是带来的问题是鱼饿死
* 循环等待，编程的难度加大，比较复杂,因为两个进程互斥的代码是不一样的。

那其实我们要解决的问题是：在同步的基础上，如何做到多线程的互斥。

* 将喂养金鱼看成是一个房间，进入房间需要进入一个门，门上有一把锁
* 某个线程进入房间之后上锁，后面的人无法进入房间。
* 离开释放锁。

这就跟我们现实世界的🔐基本一样了。

```
lock()
if (nofeed) {
    feed()
}
unlock()

lock()
if  (nofeed) {
    feed()
}
unlock
```


## 睡觉与叫醒；生产者和消费者问题

一切问题都可以归结为生产者和消费者的问题

* 睡觉和叫醒原语可能会导致死锁问题
* 锁会有循环等待的问题「只是死锁的一个条件」

消费者睡觉之前，生成者全力生产，然后睡觉，然后切换到消费者，消费者睡觉。

睡眠的理发师问题？

 

