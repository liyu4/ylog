---
title: "Why MySQL Innodb engine use b+ tree as store of index"
date: 2020-07-06T10:13:10+08:00
draft: true
---

# 背景

这个问题是一个高频的面试问题，DBMS的数据库有一个要求，保持数据的持久性，那么放在内存中，由于内存掉电「断电」之后数据会丢失，且内存的价格很贵，所以mysql会选择磁盘「当然也可以不限制与此」作为数据持久化的存储方案。

优势如下
1： 容量大价格便宜，TB甚至PB级别「PB=1024tTB，TB=1024G」
2： 持久性，磁盘的数据不易丢失「物理的损坏除外」
3： 容易制造

劣势如下
1： 和内存相比读取速度较慢
2： 机械运动，稳定性不够「依赖磁臂的寻道等物理操作」

本质上内存和磁盘是没有对错之分，相对来说都是公平的，内存速度快，但是价格也很高，所以一般容量不会很大「成本无法负担」。磁盘虽然价格便宜，容量大，但是速度无法和内存「ROM/RAM」比。具体的场景下选择合适的方案，就是好的。

mysql作为关系型数据库，单表的数据量可支持到千万级别，其所产生的数据量可以达到几百G,甚至可以达到TB的级别，这些数据都存储在内存中是不现实；1：无法常驻这些数据在内存中，2：无法保证基本的特性，也就是持久性。所以选择磁盘储存是一个比较现实的方案。

当一个慢查询出来之后，我们第一时间可能是思考是不是对应字段的索引没有添加。言下之意就是，索引可以提高查询的速度，那么索引的实现，自然是一个值得讨论的问题，即为什么索引可以提高查询速度，他有什么优劣，难道是上帝的magic？


# 二插树「binary tree/binary search tree」

二叉树的定义是，任意左子树节点的值小于根节点，任意右子树节点的值大于根节点的值。

为什么要发明这种数据结构，是因为数组，链表都存在各自的性能问题，然后二叉树的查找，删除，插入的算法平均复杂度大概是O(logN)其中N是树的层高。

为什么说平均情况呢，因为二叉树最差的情况下会退化成链表。那么我们知道链表的查找和删除是算法复杂度是O(n), 这显然是我们不想看到的不平衡的情况，
这会造成性能的突然下降。 所以为了解决这个问题，需要引入平衡二叉树。


二叉树图1-1；
![image](/img/bst+link.png)

# 平衡二叉树「self-balancing-binary-search-tree」

AVL全称自平衡树，叫这个名字是因为，这是他发明者字母的组合（G. M. Adelson-Velsky 和 E. M. Landis）。

AVL的定义是；任何节点的两子树的最大高度差别为1「注意这里说的其实是绝对值」。其删除/增加的操作通过旋转来保持平衡，并且左右两个子树都是平衡的。

旋转分为ll，rr，lr，rl四种操作，其可以保证avl的高度平衡。但是大量平衡操作非常耗费时间。


# b树

为什么要发明b树。 b树是多路平衡查找树，相对于avl或者红黑树来讲，树高更低，更加有理由磁盘的I/O, b树的每一个节点，非叶子节点和叶子节点，都存储了真实的数据，导致m阶不会太大。

# b+树

b+树是b树的改进，非叶子节点存的是索引，真实的数据存在叶子节点当中，这就意味着，假设m阶= 1000，那么只需要树高为3就可以存1000000000个索引，而I/O却非常少。
并且b+树也是有序的，对于范围查找来说，可以利用局部性原理（local of reference）， 经常访问的数据可以更好的load to memory， 加快查询的速度。
总结而言，b+树是为现代磁盘而生的一种数据结构，通过压缩树的高度，获得更少的I/O, 通过索引和数据分离，存储更多的索引，更好应对大表的查询。数据通过双向链表连接在一起。





links:
https://baike.baidu.com/item/AVL%E6%A0%91/10986648?fr=aladdinss