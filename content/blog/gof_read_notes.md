---
title: "Gof_read_notes"
date: 2020-06-11T15:49:17+08:00
draft: true
---

设计模式，是一种经验集合，这些经验和经验的实践历经了时间的考验，渐渐变成了可以开箱就用的工具，而学习这些工具的最好办法就是了解它的演变史，并且实践和掌握它的具体用法，但是设计模式不是万能的解药，但是它也是极其极其重要的。



# 设计原则（这一点非常重要，你可以忘记设计模式，但是别忘记【原则】
* 封装变化。
* 多用组合（composition），少用继承（extend）。
* 针对接口编程，不针对实现编程。
* 为了交互对象之间的松耦合设计而做努力。
* 类应该对扩展开放，对修改关闭。这一点不分语言，理论上都需要这样，好处是新功能的引入不会影响到既有的功能。具体体现就是引入bug会很少，甚至没有。

# 模式的目的

* 可复用
* 可维护
* 可扩张

唯有这样，宝贵精力的才不会陷入无穷无尽的修改和奔波当中。


# 模式概述+金句解读

_**策略模式**_；

定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。

_**策略模式人话版本**_；

 当你需要给朋友留下深刻的印象，或者是想让你的第三个女朋友答应嫁给你，请使用这个【定义】。


_***观察者模式***_；

在对象直接定义了一对多的依赖，这样一来，当一个对象改变改变状态，依赖的状态都会收到通知并且自动更新

* 观察者模式定义了对象之间一对多的关系。
* 被观察者（也就是subject）用一个共同的接口来更新观察者。
* 观察者和可观察者之间用松耦合的方式结合，可观察者不知道观察者的实现细节，只知道观察者实现了观察者接口。
* 使用此模式可以使用push或者pull的拉取方式，一般认识push是正确的。
* 如果有多个观察者，不能依赖通知的顺序。
* 尽量自己实现，而不是用java的内置工具。
* 依赖抽象，而不是具体的类。
  
_***装饰者模式***_；
 动态的将责任附加到对象上，提供了一种区别于继承的扩张方法。
按照我的理解，装饰者模式非常的类似于组合，单不同的是，就如定义中“动态的将责任附加到对象上”，这种组合关系是非常明确的，基础对象，比如书中的例子”星巴克咖啡“，可能有m种，每种有n个装饰对象，一杯咖啡，可以有牛奶的添加，糖的添加，甚至杯子的大小，也可以装饰咖啡，所以我才说这种组合关系是明确的，并且他们都有共通的特性，比如有自己描述（”牛奶“，”可卡”，“大杯”），价格（1毛钱，5毛钱）。

这样的装饰下，对象也遵循了对扩张开放，对修改关闭。但是也不是说没有问题，装饰者对象足够下，且足够多的时候，也会给开发人员带来困恼。

并且它的具体实现；当然这里说的都是面向接口编程而不是具体的实现
```java
d1 = new concreted1(d1)
d1 = new concreted2(d1)
d1 = new concreted3(d1)
d1 = new concreted4(d1)
d1 = new concreted5(d1)
.
.
.

这种写法如果写多了，就要跟小学生数数一样，看看自己出错在哪里了😄

而且具体的调用过程类似递归，装饰者最终调用到被装饰者，然后再层层返回。
```


_***工厂方法模式***_；
定义了创建对象的接口，但是由子类决定实例化的类是哪一个。工厂方法的存在让类把实例化推迟到子类。

比如某一种指定类型的pizza店，当客户下单的时候，才会去调用工厂方法，让其返回给我一个pizza，也就是createpizza（），
那么所有的子类就是具体的pizza，而延迟实例化，就是当需要的时候才去实例化具体的pizza。

这样做的好处是什么？ 抽象了创建pizz的过程，任何人都可以开一个pizza店，只要有需要的时候（实例化）。

_****抽象工厂模式***_；
工厂方法中的创建对象的接口，就是抽象工厂模式，对象列举了依赖的对象，但是不关心具体的类是如何实现的。这是不是很抽象啊，抽象就对了嘛😄。

记住这里举了一个非常生动的例子，就是星巴兹咖啡，它被称为被装饰者，装饰者是：摩卡，牛奶，糖，甚至杯子的size都是。



_***单件模式***_；
确保一个类只有一个实例，并且提供一种全局的访问方式。

* 同步方法，java有synchronized关键字保证，golang没有这种并发同步元语
* 双重检查加锁，可以使用mux来实现，第一步检查对象是否为空，加锁，检查对象是否为空，这就是双重检查和加锁的体现。

_***命令模式***_；
命令模式的结论我觉得比较的晦涩，还是通过原则加上自己的理解。

命令模式最好的例子就是对象村的餐厅

1. 客户填写菜单 （client， write command，command就是菜）
2. 服务员拿到菜单 （set command，服务员是invoker也就是调用者）
3. 服务员将菜单传递给厨师 （厨师是接收者，也就是说，服务员不知道菜单是啥，也不关心，服务员手里的菜单和厨师是解耦的）
4. 厨师按照菜单上的菜执行动作，啥动作啊，做菜呗。 （执行菜单上的command，每一个command上面有execute）



要点
* 命令模式将发出请求的对象和执行请求的对象解耦合
* 在被解耦的两者之间是通过command对象来沟通的，command对象封装了接收者的一个或者一组动作（action）
* 调用者通过执行execute（）发去请求，这会使得接收者的action被调用。
* 调用者可以接受命令当作参数，甚至在运行时也是如此。
* 命令对象可以实现撤销，做法就是实现一个undo（）方法，使得对象回到execute（）前的状态。
* 重点来了，实际操作时，很常见使用“聪明”的命令对象，也就是直接实现了请求，而不是将工作委托给接收者。
* 命令模式的常见例子，日志系统和事物系统。

还是说下定义吧：

将请求封装成对象，这可以让你使用不同的请求，队列，或者日志请求来参数化其他对象。命令模式也支持撤销动作。


_***随遇而安 适配器模式和外观模式***_

