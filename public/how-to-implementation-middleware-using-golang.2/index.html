<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.63.2" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="baidu-site-verification" content="75p3MP7oWe" />
  <script data-ad-client="ca-pub-8179589660494169" async
    src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


  <title>[GO]web中间件(2) &middot; aliasliyu4</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="/css/poole.css">
  <link type="text/css" rel="stylesheet" href="/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class="theme-base-08 ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="/"><h1>aliasliyu4</h1></a>
      <p class="lead">
       不再是少年 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2020. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>[GO]web中间件(2)</h1>
  <time datetime=2020-02-25T11:48:49&#43;0800 class="post-date">Tue, Feb 25, 2020</time>
  <p>书接上文</p>
<h5 id="定义属于你的myhandler接口-任何实现其servehttp方法的类型都可以当作是myhandler">定义属于你的MyHandler接口, 任何实现其ServeHTTP方法的类型都可以当作是MyHandler。</h5>
<pre><code>type MyHandler interface {
	ServeHTTP(w http.ResponserWriter, r *http.Request, next http.HandlerFunc) 
}
next是下一个需要执行的http Handler，它作为一个参数被传递进去。
</code></pre><h5 id="仿照nethttp定义一个函数类型myhandlerfunc-实现servehttp方法">仿照net/http定义一个函数类型MyHandlerFunc, 实现ServeHTTP方法。</h5>
<pre><code>type MyHandlerFunc func (w http.ResponseWriter, r *http.Request, next http.HandlerFunc)

func (h MyHandlerFunc) ServeHTTP(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
	h(w, r, next) // 调用ServeHTTP就是执行具体的MyHandlerFunc, 需要手动执行next函数
}
</code></pre><h5 id="定义一个中间件middleware-middlerware的数据结构像是一个单向链表可以包裹n个前置服务也可以将需要执行的逻辑放在最后的位置">定义一个中间件middleware， middlerware的数据结构像是一个单向链表，可以包裹n个前置服务，也可以将需要执行的逻辑放在最后的位置。</h5>
<pre><code>type middleware struct {
	handler MyHandler // 当前Handler
	next middleware   // 下一个需要执行的middleware
}

// 实现ServeHTTP方法,也就是实现了http Handler.
func (m *middlerware) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// m.next.ServeHTTP 自己调用自己，可以理解成进入下一个middleware
	m.handler.ServeHTTP(w, r, m.next.ServeHTTP) 
}
</code></pre><p>如上，midllerware就是一个Handler, 可在mux中注册，我们举个例子:</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;net/http&quot;
)

type MyHandler interface {
	ServeHTTP(w http.ResponseWriter, r *http.Request, next http.HandlerFunc)
}

type MyHandlerFunc func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc)

func (h MyHandlerFunc) ServeHTTP(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
	h(w, r, next) // 调用ServerHTTP就是执行具体的MyHandlerFunc, 需要手动执行next函数
}

type middleware struct {
	handler MyHandler   // 当前Handler
	next    *middleware // 下一个需要执行的middleware
}

// 实现ServeHTTP方法,也就是实现了http Handler.
func (m middleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// m.next.ServeHTTP 自己调用自己，可以理解成进入下一个middleware
	m.handler.ServeHTTP(w, r, m.next.ServeHTTP)
}

func build(myHandlers []MyHandler) middleware {
	var next middleware

	if len(myHandlers) == 0 {
		return voidMiddleware()
	} else if len(myHandlers) &gt; 1 {
		next = build(myHandlers[1:])
	} else {
		next = voidMiddleware()
	}

	return middleware{myHandlers[0], &amp;next}
}

func voidMiddleware() middleware {
	return middleware{
		MyHandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {}),
		&amp;middleware{},
	}
}

var myHandlerOne = MyHandlerFunc(func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
	fmt.Println(&quot;use myHandlerOne&quot;)
	next(w, r)
})

var myHandlerTwo = MyHandlerFunc(func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
	fmt.Println(&quot;use myHandlerTwo&quot;)
	next(w, r)
})

var loveFunc = func(w http.ResponseWriter, r *http.Request) {
	fmt.Println(&quot;you come you see&quot;)
	w.Write([]byte(&quot;i love golang&quot;))
}

func get(handler http.HandlerFunc) MyHandlerFunc {
	return func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
		handler.ServeHTTP(w, r) // http.HandlerFunc实际调用f(w, r)
		next(w, r)              // 后面执行的handler,当然你也写成next.ServeHTTP(w, r),这和next(w, r)本质是一样的
	}
}

func main() {
	myHandlers := []MyHandler{myHandlerOne, myHandlerTwo, get(loveFunc)}
	m := build(myHandlers)
	mux := http.NewServeMux()
	mux.Handle(&quot;/youqu&quot;, m)
	http.ListenAndServe(&quot;:1234&quot;, mux)
}

</code></pre><h5 id="看看效果">看看效果</h5>
<p><img src="http://ww1.sinaimg.cn/large/9b6074eegy1fvpcqu6vafj21s40cq102.jpg" alt=""></p>
<h4 id="为什么要手动执行一下nextw-r">为什么要手动执行一下next(w, r)</h4>
<p>显然我们看到myHandlerTwo，myHandlerTwo在函数的结尾处调用next(w, r), 其传参数为m.next.ServeHTTP,其本身为函数类型即：func, m.handler.ServeHTTP(w, r, m.next.ServeHTTP), 这里做了匿名转换，将其转换为http.HandlerFunc, 当然显示的转换是更加容易理解的， m.handler.ServeHTTP(w, r, http.HandlerFunc(m.next.ServeHTTP))。 当我们执行next(w, r)的时候其实执行就是m.next.ServeHTTP(w, r), 由此可见，中间件才能往下执行。</p>
<h4 id="总结">总结</h4>
<p>灵魂在于ServeHTTP函数和Handler接口，一个请求进来会调用ServeHTTP, 然后找到对应的handler, 对应下图的handle（w, req, ps）
<img src="http://ww1.sinaimg.cn/large/9b6074eegy1fvpcjt25d8j21dq0f2dlu.jpg" alt="">
handle如何执行呢？ 他会调用Handler的ServeHTTP, 在我们的例子里就是middlerware的ServeHTTP.
<img src="http://ww1.sinaimg.cn/large/9b6074eegy1fvpcm4omj6j21a60cu79w.jpg" alt=""></p>
<p>大概中间件就是这样运行起来的, 如果你完全懂了，那就可以实战了。</p>
<p>完结。</p>
</div>


    </main>

    
  </body>
</html>
