<!DOCTYPE html>
<html lang="en-us"><head>
    
    <meta charset="utf-8">
     
    <meta name="viewport" content="with=device-width, initial-scale=1, viewport-fit=cover">
    
    <title>Gof_read_notes | 自由.自在</title>
    <meta name="description" content="设计模式，是一种经验集合，这些经验和经验的实践历经了时间的考验，渐渐变成了可以开箱就用的工具，而学习这些工具的最好办法就是了解它的演变史，并且实践和掌握它的具体用法，但是设计模式不是万能的解药，但是它也是极其极其重要的。
设计原则（这一点非常重要，你可以忘记设计模式，但是别忘记【原则】  封装变化。 多用组合（composition），少用继承（extend）。 针对接口编程，不针对实现编程。 为了交互对象之间的松耦合设计而做努力。 类应该对扩展开放，对修改关闭。这一点不分语言，理论上都需要这样，好处是新功能的引入不会影响到既有的功能。具体体现就是引入bug会很少，甚至没有。 最少知识原则，只和你的密友谈话。 别找我，我会去找你。我指高级的类，你指低层级的类。 单一原则，一个类应该只有一个引起变化的原因，往往遵循此原则的类，也会高内聚。  模式的目的  可复用 可维护 可扩张  唯有这样，宝贵精力的才不会陷入无穷无尽的修改和奔波当中。
模式概述&#43;金句解读 策略模式；
定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。
策略模式人话版本；
当你需要给朋友留下深刻的印象，或者是想让你的第三个女朋友答应嫁给你，请使用这个【定义】。
观察者模式；
在对象直接定义了一对多的依赖，这样一来，当一个对象改变改变状态，依赖的状态都会收到通知并且自动更新
 观察者模式定义了对象之间一对多的关系。 被观察者（也就是subject）用一个共同的接口来更新观察者。 观察者和可观察者之间用松耦合的方式结合，可观察者不知道观察者的实现细节，只知道观察者实现了观察者接口。 使用此模式可以使用push或者pull的拉取方式，一般认识push是正确的。 如果有多个观察者，不能依赖通知的顺序。 尽量自己实现，而不是用java的内置工具。 依赖抽象，而不是具体的类。  装饰者模式； 动态的将责任附加到对象上，提供了一种区别于继承的扩张方法。 按照我的理解，装饰者模式非常的类似于组合，单不同的是，就如定义中“动态的将责任附加到对象上”，这种组合关系是非常明确的，基础对象，比如书中的例子”星巴克咖啡“，可能有m种，每种有n个装饰对象，一杯咖啡，可以有牛奶的添加，糖的添加，甚至杯子的大小，也可以装饰咖啡，所以我才说这种组合关系是明确的，并且他们都有共通的特性，比如有自己描述（”牛奶“，”可卡”，“大杯”），价格（1毛钱，5毛钱）。
这样的装饰下，对象也遵循了对扩张开放，对修改关闭。但是也不是说没有问题，装饰者对象足够下，且足够多的时候，也会给开发人员带来困恼。
并且它的具体实现；当然这里说的都是面向接口编程而不是具体的实现
d1 = new concreted1(d1) d1 = new concreted2(d1) d1 = new concreted3(d1) d1 = new concreted4(d1) d1 = new concreted5(d1) . . . 这种写法如果写多了，就要跟小学生数数一样，看看自己出错在哪里了😄 而且具体的调用过程类似递归，装饰者最终调用到被装饰者，然后再层层返回。 工厂方法模式； 定义了创建对象的接口，但是由子类决定实例化的类是哪一个。工厂方法的存在让类把实例化推迟到子类。
比如某一种指定类型的pizza店，当客户下单的时候，才会去调用工厂方法，让其返回给我一个pizza，也就是createpizza（）， 那么所有的子类就是具体的pizza，而延迟实例化，就是当需要的时候才去实例化具体的pizza。
这样做的好处是什么？ 抽象了创建pizz的过程，任何人都可以开一个pizza店，只要有需要的时候（实例化）。 ">
    <meta property="description" content="My site description" />
    <link rel="stylesheet" href="/front/bulma.min.css">
    <link rel="canonical" href="/2020/06/gof_read_notes/" />
    <link rel="stylesheet" href="/front/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
    <link rel="stylesheet" href="/css/style.css" />
    <link rel='icon' href='https://ftp.bmp.ovh/imgs/2020/09/d2c3225b7119bc23.jpg' type='image/x-icon' />
    <meta property="og:title" content="Gof_read_notes" />
<meta property="og:description" content="设计模式，是一种经验集合，这些经验和经验的实践历经了时间的考验，渐渐变成了可以开箱就用的工具，而学习这些工具的最好办法就是了解它的演变史，并且实践和掌握它的具体用法，但是设计模式不是万能的解药，但是它也是极其极其重要的。
设计原则（这一点非常重要，你可以忘记设计模式，但是别忘记【原则】  封装变化。 多用组合（composition），少用继承（extend）。 针对接口编程，不针对实现编程。 为了交互对象之间的松耦合设计而做努力。 类应该对扩展开放，对修改关闭。这一点不分语言，理论上都需要这样，好处是新功能的引入不会影响到既有的功能。具体体现就是引入bug会很少，甚至没有。 最少知识原则，只和你的密友谈话。 别找我，我会去找你。我指高级的类，你指低层级的类。 单一原则，一个类应该只有一个引起变化的原因，往往遵循此原则的类，也会高内聚。  模式的目的  可复用 可维护 可扩张  唯有这样，宝贵精力的才不会陷入无穷无尽的修改和奔波当中。
模式概述&#43;金句解读 策略模式；
定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。
策略模式人话版本；
当你需要给朋友留下深刻的印象，或者是想让你的第三个女朋友答应嫁给你，请使用这个【定义】。
观察者模式；
在对象直接定义了一对多的依赖，这样一来，当一个对象改变改变状态，依赖的状态都会收到通知并且自动更新
 观察者模式定义了对象之间一对多的关系。 被观察者（也就是subject）用一个共同的接口来更新观察者。 观察者和可观察者之间用松耦合的方式结合，可观察者不知道观察者的实现细节，只知道观察者实现了观察者接口。 使用此模式可以使用push或者pull的拉取方式，一般认识push是正确的。 如果有多个观察者，不能依赖通知的顺序。 尽量自己实现，而不是用java的内置工具。 依赖抽象，而不是具体的类。  装饰者模式； 动态的将责任附加到对象上，提供了一种区别于继承的扩张方法。 按照我的理解，装饰者模式非常的类似于组合，单不同的是，就如定义中“动态的将责任附加到对象上”，这种组合关系是非常明确的，基础对象，比如书中的例子”星巴克咖啡“，可能有m种，每种有n个装饰对象，一杯咖啡，可以有牛奶的添加，糖的添加，甚至杯子的大小，也可以装饰咖啡，所以我才说这种组合关系是明确的，并且他们都有共通的特性，比如有自己描述（”牛奶“，”可卡”，“大杯”），价格（1毛钱，5毛钱）。
这样的装饰下，对象也遵循了对扩张开放，对修改关闭。但是也不是说没有问题，装饰者对象足够下，且足够多的时候，也会给开发人员带来困恼。
并且它的具体实现；当然这里说的都是面向接口编程而不是具体的实现
d1 = new concreted1(d1) d1 = new concreted2(d1) d1 = new concreted3(d1) d1 = new concreted4(d1) d1 = new concreted5(d1) . . . 这种写法如果写多了，就要跟小学生数数一样，看看自己出错在哪里了😄 而且具体的调用过程类似递归，装饰者最终调用到被装饰者，然后再层层返回。 工厂方法模式； 定义了创建对象的接口，但是由子类决定实例化的类是哪一个。工厂方法的存在让类把实例化推迟到子类。
比如某一种指定类型的pizza店，当客户下单的时候，才会去调用工厂方法，让其返回给我一个pizza，也就是createpizza（）， 那么所有的子类就是具体的pizza，而延迟实例化，就是当需要的时候才去实例化具体的pizza。
这样做的好处是什么？ 抽象了创建pizz的过程，任何人都可以开一个pizza店，只要有需要的时候（实例化）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/2020/06/gof_read_notes/" />
<meta property="og:image" content="https://ftp.bmp.ovh/imgs/2020/09/d2c3225b7119bc23.jpg"/>
<meta property="article:published_time" content="2020-06-11T15:49:17+08:00" />
<meta property="article:modified_time" content="2020-06-11T15:49:17+08:00" />

    <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://ftp.bmp.ovh/imgs/2020/09/d2c3225b7119bc23.jpg"/>

<meta name="twitter:title" content="Gof_read_notes"/>
<meta name="twitter:description" content="设计模式，是一种经验集合，这些经验和经验的实践历经了时间的考验，渐渐变成了可以开箱就用的工具，而学习这些工具的最好办法就是了解它的演变史，并且实践和掌握它的具体用法，但是设计模式不是万能的解药，但是它也是极其极其重要的。
设计原则（这一点非常重要，你可以忘记设计模式，但是别忘记【原则】  封装变化。 多用组合（composition），少用继承（extend）。 针对接口编程，不针对实现编程。 为了交互对象之间的松耦合设计而做努力。 类应该对扩展开放，对修改关闭。这一点不分语言，理论上都需要这样，好处是新功能的引入不会影响到既有的功能。具体体现就是引入bug会很少，甚至没有。 最少知识原则，只和你的密友谈话。 别找我，我会去找你。我指高级的类，你指低层级的类。 单一原则，一个类应该只有一个引起变化的原因，往往遵循此原则的类，也会高内聚。  模式的目的  可复用 可维护 可扩张  唯有这样，宝贵精力的才不会陷入无穷无尽的修改和奔波当中。
模式概述&#43;金句解读 策略模式；
定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。
策略模式人话版本；
当你需要给朋友留下深刻的印象，或者是想让你的第三个女朋友答应嫁给你，请使用这个【定义】。
观察者模式；
在对象直接定义了一对多的依赖，这样一来，当一个对象改变改变状态，依赖的状态都会收到通知并且自动更新
 观察者模式定义了对象之间一对多的关系。 被观察者（也就是subject）用一个共同的接口来更新观察者。 观察者和可观察者之间用松耦合的方式结合，可观察者不知道观察者的实现细节，只知道观察者实现了观察者接口。 使用此模式可以使用push或者pull的拉取方式，一般认识push是正确的。 如果有多个观察者，不能依赖通知的顺序。 尽量自己实现，而不是用java的内置工具。 依赖抽象，而不是具体的类。  装饰者模式； 动态的将责任附加到对象上，提供了一种区别于继承的扩张方法。 按照我的理解，装饰者模式非常的类似于组合，单不同的是，就如定义中“动态的将责任附加到对象上”，这种组合关系是非常明确的，基础对象，比如书中的例子”星巴克咖啡“，可能有m种，每种有n个装饰对象，一杯咖啡，可以有牛奶的添加，糖的添加，甚至杯子的大小，也可以装饰咖啡，所以我才说这种组合关系是明确的，并且他们都有共通的特性，比如有自己描述（”牛奶“，”可卡”，“大杯”），价格（1毛钱，5毛钱）。
这样的装饰下，对象也遵循了对扩张开放，对修改关闭。但是也不是说没有问题，装饰者对象足够下，且足够多的时候，也会给开发人员带来困恼。
并且它的具体实现；当然这里说的都是面向接口编程而不是具体的实现
d1 = new concreted1(d1) d1 = new concreted2(d1) d1 = new concreted3(d1) d1 = new concreted4(d1) d1 = new concreted5(d1) . . . 这种写法如果写多了，就要跟小学生数数一样，看看自己出错在哪里了😄 而且具体的调用过程类似递归，装饰者最终调用到被装饰者，然后再层层返回。 工厂方法模式； 定义了创建对象的接口，但是由子类决定实例化的类是哪一个。工厂方法的存在让类把实例化推迟到子类。
比如某一种指定类型的pizza店，当客户下单的时候，才会去调用工厂方法，让其返回给我一个pizza，也就是createpizza（）， 那么所有的子类就是具体的pizza，而延迟实例化，就是当需要的时候才去实例化具体的pizza。
这样做的好处是什么？ 抽象了创建pizz的过程，任何人都可以开一个pizza店，只要有需要的时候（实例化）。"/>

    <script src="/front/jquery-3.5.1.min.js" integrity="sha256-xNzN2a4ltkB44Mc/Jz3pT4iU1cmeR0FkXs4pru/JxaQ=" crossorigin="anonymous"></script>
</head><body><header>
    <nav class="navbar" role="navigation">
        <div class="container">
            <div class="navbar-brand">
                <a href="/blog" title="home"  class="navbar-item">
                    <span class="logo">
                       <h1>自由.自在</h1>
                </a>

                
                <a  href="https://github.com/liyu4" class="navbar-item is-hidden-desktop" title="GitHub">
                </span>
                </a>
                
                <a  href="https://twitter.com/liyu7771" class="navbar-item is-hidden-desktop" title="Twitter">
                </span>
                </a>
                
                <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
                    <span aria-hidden="true"></span>
                    <span aria-hidden="true"></span>
                    <span aria-hidden="true"></span>
                </a>
            </div>

           


            <div class="navbar-menu">
                <div class="navbar-start">
                    
                </div>

                <div  class="navbar-end">
                    
                    <a href="https://github.com/liyu4" class="navbar-item is-hidden-touch" title="GitHub">
                        <span class="icon"><i class='fab fa-github'></i></span>
                    </a>
                    
                    <a href="https://twitter.com/liyu7771" class="navbar-item is-hidden-touch" title="Twitter">
                        <span class="icon"><i class='fab fa-twitter'></i></span>
                    </a>
                    
                </div>
            </div>
        </div>
    </nav>

    <script>
        $(document).ready(function () {
            $(".navbar-burger").click(function () {
                $(".navbar-burger").toggleClass("is-active");
                $(".navbar-menu").toggleClass("is-active");
            })
        })
    </script>

</header><main>
<section class="section">
    <article>
        <div class="columns is-centered">
            <div class="column max-800px">
             <h1 class="title is-1">Gof_read_notes</h1>
            <div class="title subtitle heading is-6">
                <div class="columns is-vcentered is-mobile">
                    
                    <div class="column is-narrow">
                        <img src="https://ftp.bmp.ovh/imgs/2020/09/d2c3225b7119bc23.jpg" class="author-image">
                    </div>
                    
                    <div class="column">
                        <p>杨修</p>
                        <p><time>June 11, 2020</time> |
                            1  minute </p>
                    </div>
                </div>

            <div class="content">
            <p>设计模式，是一种经验集合，这些经验和经验的实践历经了时间的考验，渐渐变成了可以开箱就用的工具，而学习这些工具的最好办法就是了解它的演变史，并且实践和掌握它的具体用法，但是设计模式不是万能的解药，但是它也是极其极其重要的。</p>
<h1 id="设计原则这一点非常重要你可以忘记设计模式但是别忘记原则">设计原则（这一点非常重要，你可以忘记设计模式，但是别忘记【原则】</h1>
<ul>
<li>封装变化。</li>
<li>多用组合（composition），少用继承（extend）。</li>
<li>针对接口编程，不针对实现编程。</li>
<li>为了交互对象之间的松耦合设计而做努力。</li>
<li>类应该对扩展开放，对修改关闭。这一点不分语言，理论上都需要这样，好处是新功能的引入不会影响到既有的功能。具体体现就是引入bug会很少，甚至没有。</li>
<li>最少知识原则，只和你的密友谈话。</li>
<li>别找我，我会去找你。我指高级的类，你指低层级的类。</li>
<li>单一原则，一个类应该只有一个引起变化的原因，往往遵循此原则的类，也会高内聚。</li>
</ul>
<h1 id="模式的目的">模式的目的</h1>
<ul>
<li>可复用</li>
<li>可维护</li>
<li>可扩张</li>
</ul>
<p>唯有这样，宝贵精力的才不会陷入无穷无尽的修改和奔波当中。</p>
<h1 id="模式概述金句解读">模式概述+金句解读</h1>
<p><em><strong>策略模式</strong></em>；</p>
<p>定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</p>
<p><em><strong>策略模式人话版本</strong></em>；</p>
<p>当你需要给朋友留下深刻的印象，或者是想让你的第三个女朋友答应嫁给你，请使用这个【定义】。</p>
<p><em><em><strong>观察者模式</strong></em></em>；</p>
<p>在对象直接定义了一对多的依赖，这样一来，当一个对象改变改变状态，依赖的状态都会收到通知并且自动更新</p>
<ul>
<li>观察者模式定义了对象之间一对多的关系。</li>
<li>被观察者（也就是subject）用一个共同的接口来更新观察者。</li>
<li>观察者和可观察者之间用松耦合的方式结合，可观察者不知道观察者的实现细节，只知道观察者实现了观察者接口。</li>
<li>使用此模式可以使用push或者pull的拉取方式，一般认识push是正确的。</li>
<li>如果有多个观察者，不能依赖通知的顺序。</li>
<li>尽量自己实现，而不是用java的内置工具。</li>
<li>依赖抽象，而不是具体的类。</li>
</ul>
<p><em><em><strong>装饰者模式</strong></em></em>；
动态的将责任附加到对象上，提供了一种区别于继承的扩张方法。
按照我的理解，装饰者模式非常的类似于组合，单不同的是，就如定义中“动态的将责任附加到对象上”，这种组合关系是非常明确的，基础对象，比如书中的例子”星巴克咖啡“，可能有m种，每种有n个装饰对象，一杯咖啡，可以有牛奶的添加，糖的添加，甚至杯子的大小，也可以装饰咖啡，所以我才说这种组合关系是明确的，并且他们都有共通的特性，比如有自己描述（”牛奶“，”可卡”，“大杯”），价格（1毛钱，5毛钱）。</p>
<p>这样的装饰下，对象也遵循了对扩张开放，对修改关闭。但是也不是说没有问题，装饰者对象足够下，且足够多的时候，也会给开发人员带来困恼。</p>
<p>并且它的具体实现；当然这里说的都是面向接口编程而不是具体的实现</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">d1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> concreted1<span style="color:#f92672">(</span>d1<span style="color:#f92672">)</span>
d1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> concreted2<span style="color:#f92672">(</span>d1<span style="color:#f92672">)</span>
d1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> concreted3<span style="color:#f92672">(</span>d1<span style="color:#f92672">)</span>
d1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> concreted4<span style="color:#f92672">(</span>d1<span style="color:#f92672">)</span>
d1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> concreted5<span style="color:#f92672">(</span>d1<span style="color:#f92672">)</span>
<span style="color:#f92672">.</span>
<span style="color:#f92672">.</span>
<span style="color:#f92672">.</span>

这种写法如果写多了<span style="color:#960050;background-color:#1e0010">，</span>就要跟小学生数数一样<span style="color:#960050;background-color:#1e0010">，</span>看看自己出错在哪里了<span style="color:#960050;background-color:#1e0010">😄</span>

而且具体的调用过程类似递归<span style="color:#960050;background-color:#1e0010">，</span>装饰者最终调用到被装饰者<span style="color:#960050;background-color:#1e0010">，</span>然后再层层返回<span style="color:#960050;background-color:#1e0010">。</span>
</code></pre></div><p><em><em><strong>工厂方法模式</strong></em></em>；
定义了创建对象的接口，但是由子类决定实例化的类是哪一个。工厂方法的存在让类把实例化推迟到子类。</p>
<p>比如某一种指定类型的pizza店，当客户下单的时候，才会去调用工厂方法，让其返回给我一个pizza，也就是createpizza（），
那么所有的子类就是具体的pizza，而延迟实例化，就是当需要的时候才去实例化具体的pizza。</p>
<p>这样做的好处是什么？ 抽象了创建pizz的过程，任何人都可以开一个pizza店，只要有需要的时候（实例化）。</p>
<p><em>*<em><strong>抽象工厂模式</strong></em></em>；
工厂方法中的创建对象的接口，就是抽象工厂模式，对象列举了依赖的对象，但是不关心具体的类是如何实现的。这是不是很抽象啊，抽象就对了嘛😄。</p>
<p>记住这里举了一个非常生动的例子，就是星巴兹咖啡，它被称为被装饰者，装饰者是：摩卡，牛奶，糖，甚至杯子的size都是。</p>
<p><em><em><strong>单件模式</strong></em></em>；
确保一个类只有一个实例，并且提供一种全局的访问方式。</p>
<ul>
<li>同步方法，java有synchronized关键字保证，golang没有这种并发同步元语</li>
<li>双重检查加锁，可以使用mux来实现，第一步检查对象是否为空，加锁，检查对象是否为空，这就是双重检查和加锁的体现。</li>
</ul>
<p><em><em><strong>命令模式</strong></em></em>；
命令模式的结论我觉得比较的晦涩，还是通过原则加上自己的理解。</p>
<p>命令模式最好的例子就是对象村的餐厅</p>
<ol>
<li>客户填写菜单 （client， write command，command就是菜）</li>
<li>服务员拿到菜单 （set command，服务员是invoker也就是调用者）</li>
<li>服务员将菜单传递给厨师 （厨师是接收者，也就是说，服务员不知道菜单是啥，也不关心，服务员手里的菜单和厨师是解耦的）</li>
<li>厨师按照菜单上的菜执行动作，啥动作啊，做菜呗。 （执行菜单上的command，每一个command上面有execute）</li>
</ol>
<p>要点</p>
<ul>
<li>命令模式将发出请求的对象和执行请求的对象解耦合</li>
<li>在被解耦的两者之间是通过command对象来沟通的，command对象封装了接收者的一个或者一组动作（action）</li>
<li>调用者通过执行execute（）发去请求，这会使得接收者的action被调用。</li>
<li>调用者可以接受命令当作参数，甚至在运行时也是如此。</li>
<li>命令对象可以实现撤销，做法就是实现一个undo（）方法，使得对象回到execute（）前的状态。</li>
<li>重点来了，实际操作时，很常见使用“聪明”的命令对象，也就是直接实现了请求，而不是将工作委托给接收者。</li>
<li>命令模式的常见例子，日志系统和事物系统。</li>
</ul>
<p>还是说下定义吧：</p>
<p>将请求封装成对象，这可以让你使用不同的请求，队列，或者日志请求来参数化其他对象。命令模式也支持撤销动作。</p>
<p><em><em><strong>随遇而安 适配器模式和外观模式</strong></em></em>
适配器模式的绝佳case，港行的电子产品的插头是三角插头，无法使用国内的“正常”插座，那可咋办？</p>
<ul>
<li>猛男将其掰正，画面太美太暴力。</li>
<li>万能淘宝一顿search发现了，还有适配器这个东西。</li>
<li>港行的插头往适配器上一插，适配器再往国内的插座来那么一下，神奇的事情就发生了，一切都正常了。</li>
</ul>
<p>这个case很生动的解释了适配器的作用，它将插座转换成了可以适配港行的插头，其实反过来将也是可以的，只是这样适配器就被其独占了。还是第一种描述较为靠谱。</p>
<p>当然还有更加经典的说法：</p>
<p>当一只🐔走路看上去像🦆，叫起来像🦆，那么它必定可能是一只🦆 ps： 包装了鸭子适配器的🐔</p>
<p>定义
将一个类的接口（java可以这样叫 ），转换成客户期望的另一个接口。适配器让原本不兼容的类可以相互之间合作。</p>
<p>外观模式：丑陋总是让人自卑，赋予一个好看的外观，在这个时代变得非常重要，所以我们就称外观模式为变得各种类变得好看的模式。</p>
<p>经典的例子就是，家庭影院，由复杂的子系统组成，dvd，幕布，放映机，灯光系统，影响系统。这些组合使得在看电影之前需要做非常多的操作，
光是记住这些仪器的操作就已经很难了，所以提供一个统一简洁的接口，使得看电影变得简单，这就是外观模式的威力。</p>
<p>类之间的相互依赖会造成系统的脆弱，后期难以维护。</p>
<p>对象不要赢得太多朋友和影响太多的对象，解决此问题？ 就任何对象，此对象的方法内，我们只应该调用属于如下范围内的方法；</p>
<ul>
<li>属于对象本身的方法</li>
<li>被当作方法参数传递进来的对象</li>
<li>此方法所创建或者实例化的任何对象</li>
<li>前面三条的意思是说，如果某对象是调用方法的返回值，则不要调用改返回对象的方法</li>
<li>对象的任何组件</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 错误的例子
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">float</span> <span style="color:#a6e22e">getTemp</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    Thermometer thermometer <span style="color:#f92672">=</span> station<span style="color:#f92672">.</span><span style="color:#a6e22e">GetThermometer</span><span style="color:#f92672">()</span>
    <span style="color:#75715e">// 注意thermometer是方法返回的对象
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> thermometer<span style="color:#f92672">.</span><span style="color:#a6e22e">GetTemperature</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">// 正确的例子
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">float</span> <span style="color:#a6e22e">getTemp</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 减少了thermometer类的方法的引用
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 看上去代码就简洁了一些
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> station<span style="color:#f92672">.</span><span style="color:#a6e22e">GetTemperature</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><em><em><strong>模版方法模式</strong></em></em>；</p>
<p>在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中实现。模版方法模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
<p>如果需要控制算法流怎么办，在经典的咖啡和茶的制作过程中，控制client是否想添加调味品的工作可以交给hook来做，子类可以选择不覆盖，也可以选择覆盖。</p>
<p>对于如上的例子，覆盖则意味这用户不需要添加。</p>
<p>模版方法模式和策略模式有相视的既视感，但是批次是非常不一样的。</p>
<p>模版方法模式使用继承的方法实现（extend）
策略模式使用组合的方式实现（composition）</p>
<p><em><em><strong>迭代器模式</strong></em></em>；</p>
<p>提供一种顺序访问内部聚合对象中的各个元素，并且不暴露其内部的表示。</p>
<p><img src="/img/program_interface.png" alt="image">
<img src="/img/iterator.png" alt="image"></p>
<p>上图是对象村中，午餐厅和早餐厅需要合并，新来的服务员如果需要舒徐两套餐厅的菜单，就会让其手忙脚乱。从设计的角度有两个重点</p>
<ul>
<li>针对接口编程，两个餐厅共同实现一个接口</li>
<li>使用迭代器模式，将具体的内部实现屏蔽掉，比如从外部来看是不知道内部用什么存储的，事实上客户也不关心此。</li>
<li>迭代器接口，hasNext()， next()， remove()，可以自己实现，也可以使用java.util.Iterator</li>
</ul>
<p><em><em><strong>todo组合模式</strong></em></em>；</p>

            </div>
            </div>
        </div>
    </article>


    <section class="section">
        <div class="columns is-centered">
            <div class="column max-800px">
                <div class="columns is-mobile">
                    <div class="column has-text-left">
                        
                        <p>Previous post</p>
                        <a href="/2020/06/mysql-isolation-level-introduction/">MySQL Isolation Level Introduction</a>
                        
                    </div>
                    <div class="column has-text-right">
                        
                        <p>Next post</p>
                        <a href="/2020/07/redis_distributed_lock/">Redis_distributed_lock</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </section>

</section>

        </main><footer class="footer">
    <div class="container">
        <div class="columns has-text-centered">
            
            <div class="column is-narrow">
                <a href="/privacy" class="">Privacy</a>
            </div>
            
        </div>
    </div>
</footer></body>
</html>
