<!DOCTYPE html>
<html lang="en-us"><head>
    
    <meta charset="utf-8">
     
    <meta name="viewport" content="with=device-width, initial-scale=1, viewport-fit=cover">
    
    <title>[GO]web中间件(2) | 自由.自在</title>
    <meta name="description" content="书接上文 ">
    <meta property="description" content="My site description" />
    <link rel="stylesheet" href="/front/bulma.min.css">
    <link rel="canonical" href="/2020/02/goweb%E4%B8%AD%E9%97%B4%E4%BB%B62/" />
    <link rel="stylesheet" href="/front/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
    <link rel="stylesheet" href="/css/style.css" />
    <link rel='icon' href='https://ftp.bmp.ovh/imgs/2020/09/d2c3225b7119bc23.jpg' type='image/x-icon' />
    <meta property="og:title" content="[GO]web中间件(2)" />
<meta property="og:description" content="书接上文" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/2020/02/goweb%E4%B8%AD%E9%97%B4%E4%BB%B62/" />
<meta property="og:image" content="https://ftp.bmp.ovh/imgs/2020/09/d2c3225b7119bc23.jpg"/>
<meta property="article:published_time" content="2020-02-25T11:48:49+08:00" />
<meta property="article:modified_time" content="2020-02-25T11:48:49+08:00" />

    <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://ftp.bmp.ovh/imgs/2020/09/d2c3225b7119bc23.jpg"/>

<meta name="twitter:title" content="[GO]web中间件(2)"/>
<meta name="twitter:description" content="书接上文"/>

    <script src="/front/jquery-3.5.1.min.js" integrity="sha256-xNzN2a4ltkB44Mc/Jz3pT4iU1cmeR0FkXs4pru/JxaQ=" crossorigin="anonymous"></script>
</head><body><header>
    <nav class="navbar" role="navigation">
        <div class="container">
            <div class="navbar-brand">
                <a href="/blog" title="home"  class="navbar-item">
                    <span class="logo">
                       <h1>自由.自在</h1>
                </a>

                
                <a  href="https://github.com/liyu4" class="navbar-item is-hidden-desktop" title="GitHub">
                </span>
                </a>
                
                <a  href="https://twitter.com/liyu7771" class="navbar-item is-hidden-desktop" title="Twitter">
                </span>
                </a>
                
                <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
                    <span aria-hidden="true"></span>
                    <span aria-hidden="true"></span>
                    <span aria-hidden="true"></span>
                </a>
            </div>


            <div class="navbar-menu">
                <div class="navbar-start">
                    
                </div>

                <div  class="navbar-end">
                    
                    <a href="https://github.com/liyu4" class="navbar-item is-hidden-touch" title="GitHub">
                        <span class="icon"><i class='fab fa-github'></i></span>
                    </a>
                    
                    <a href="https://twitter.com/liyu7771" class="navbar-item is-hidden-touch" title="Twitter">
                        <span class="icon"><i class='fab fa-twitter'></i></span>
                    </a>
                    
                </div>
            </div>
        </div>
    </nav>

    <script>
        $(document).ready(function () {
            $(".navbar-burger").click(function () {
                $(".navbar-burger").toggleClass("is-active");
                $(".navbar-menu").toggleClass("is-active");
            })
        })
    </script>

</header><main>
<section class="section">
    <article>
        <div class="columns is-centered">
            <div class="column max-800px">
             <h1 class="title is-1">[GO]web中间件(2)</h1>
            <div class="title subtitle heading is-6">
                <div class="columns is-vcentered is-mobile">
                    
                    <div class="column is-narrow">
                        <img src="https://ftp.bmp.ovh/imgs/2020/09/d2c3225b7119bc23.jpg" class="author-image">
                    </div>
                    
                    <div class="column">
                        <p>杨修</p>
                        <p><time>February 25, 2020</time> |
                            2  minutes </p>
                    </div>
                </div>

            <div class="content">
            <p>书接上文</p>
<h5 id="定义属于你的myhandler接口-任何实现其servehttp方法的类型都可以当作是myhandler">定义属于你的MyHandler接口, 任何实现其ServeHTTP方法的类型都可以当作是MyHandler。</h5>
<pre><code>type MyHandler interface {
	ServeHTTP(w http.ResponserWriter, r *http.Request, next http.HandlerFunc) 
}
next是下一个需要执行的http Handler，它作为一个参数被传递进去。
</code></pre><h5 id="仿照nethttp定义一个函数类型myhandlerfunc-实现servehttp方法">仿照net/http定义一个函数类型MyHandlerFunc, 实现ServeHTTP方法。</h5>
<pre><code>type MyHandlerFunc func (w http.ResponseWriter, r *http.Request, next http.HandlerFunc)

func (h MyHandlerFunc) ServeHTTP(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
	h(w, r, next) // 调用ServeHTTP就是执行具体的MyHandlerFunc, 需要手动执行next函数
}
</code></pre><h5 id="定义一个中间件middleware-middlerware的数据结构像是一个单向链表可以包裹n个前置服务也可以将需要执行的逻辑放在最后的位置">定义一个中间件middleware， middlerware的数据结构像是一个单向链表，可以包裹n个前置服务，也可以将需要执行的逻辑放在最后的位置。</h5>
<pre><code>type middleware struct {
	handler MyHandler // 当前Handler
	next middleware   // 下一个需要执行的middleware
}

// 实现ServeHTTP方法,也就是实现了http Handler.
func (m *middlerware) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// m.next.ServeHTTP 自己调用自己，可以理解成进入下一个middleware
	m.handler.ServeHTTP(w, r, m.next.ServeHTTP) 
}
</code></pre><p>如上，midllerware就是一个Handler, 可在mux中注册，我们举个例子:</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;net/http&quot;
)

type MyHandler interface {
	ServeHTTP(w http.ResponseWriter, r *http.Request, next http.HandlerFunc)
}

type MyHandlerFunc func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc)

func (h MyHandlerFunc) ServeHTTP(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
	h(w, r, next) // 调用ServerHTTP就是执行具体的MyHandlerFunc, 需要手动执行next函数
}

type middleware struct {
	handler MyHandler   // 当前Handler
	next    *middleware // 下一个需要执行的middleware
}

// 实现ServeHTTP方法,也就是实现了http Handler.
func (m middleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// m.next.ServeHTTP 自己调用自己，可以理解成进入下一个middleware
	m.handler.ServeHTTP(w, r, m.next.ServeHTTP)
}

func build(myHandlers []MyHandler) middleware {
	var next middleware

	if len(myHandlers) == 0 {
		return voidMiddleware()
	} else if len(myHandlers) &gt; 1 {
		next = build(myHandlers[1:])
	} else {
		next = voidMiddleware()
	}

	return middleware{myHandlers[0], &amp;next}
}

func voidMiddleware() middleware {
	return middleware{
		MyHandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {}),
		&amp;middleware{},
	}
}

var myHandlerOne = MyHandlerFunc(func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
	fmt.Println(&quot;use myHandlerOne&quot;)
	next(w, r)
})

var myHandlerTwo = MyHandlerFunc(func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
	fmt.Println(&quot;use myHandlerTwo&quot;)
	next(w, r)
})

var loveFunc = func(w http.ResponseWriter, r *http.Request) {
	fmt.Println(&quot;you come you see&quot;)
	w.Write([]byte(&quot;i love golang&quot;))
}

func get(handler http.HandlerFunc) MyHandlerFunc {
	return func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
		handler.ServeHTTP(w, r) // http.HandlerFunc实际调用f(w, r)
		next(w, r)              // 后面执行的handler,当然你也写成next.ServeHTTP(w, r),这和next(w, r)本质是一样的
	}
}

func main() {
	myHandlers := []MyHandler{myHandlerOne, myHandlerTwo, get(loveFunc)}
	m := build(myHandlers)
	mux := http.NewServeMux()
	mux.Handle(&quot;/youqu&quot;, m)
	http.ListenAndServe(&quot;:1234&quot;, mux)
}

</code></pre><h5 id="看看效果">看看效果</h5>
<p><img src="http://ww1.sinaimg.cn/large/9b6074eegy1fvpcqu6vafj21s40cq102.jpg" alt=""></p>
<h4 id="为什么要手动执行一下nextw-r">为什么要手动执行一下next(w, r)</h4>
<p>显然我们看到myHandlerTwo，myHandlerTwo在函数的结尾处调用next(w, r), 其传参数为m.next.ServeHTTP,其本身为函数类型即：func, m.handler.ServeHTTP(w, r, m.next.ServeHTTP), 这里做了匿名转换，将其转换为http.HandlerFunc, 当然显示的转换是更加容易理解的， m.handler.ServeHTTP(w, r, http.HandlerFunc(m.next.ServeHTTP))。 当我们执行next(w, r)的时候其实执行就是m.next.ServeHTTP(w, r), 由此可见，中间件才能往下执行。</p>
<h4 id="总结">总结</h4>
<p>灵魂在于ServeHTTP函数和Handler接口，一个请求进来会调用ServeHTTP, 然后找到对应的handler, 对应下图的handle（w, req, ps）
<img src="http://ww1.sinaimg.cn/large/9b6074eegy1fvpcjt25d8j21dq0f2dlu.jpg" alt="">
handle如何执行呢？ 他会调用Handler的ServeHTTP, 在我们的例子里就是middlerware的ServeHTTP.
<img src="http://ww1.sinaimg.cn/large/9b6074eegy1fvpcm4omj6j21a60cu79w.jpg" alt=""></p>
<p>大概中间件就是这样运行起来的, 如果你完全懂了，那就可以实战了。</p>
<p>完结。</p>
            </div>
            </div>
        </div>
    </article>


    <section class="section">
        <div class="columns is-centered">
            <div class="column max-800px">
                <div class="columns is-mobile">
                    <div class="column has-text-left">
                        
                        <p>Previous post</p>
                        <a href="/2020/02/goweb%E4%B8%AD%E9%97%B4%E4%BB%B61/">[GO]web中间件(1)</a>
                        
                    </div>
                    <div class="column has-text-right">
                        
                        <p>Next post</p>
                        <a href="/2020/03/300-days-alone/">300 Days Alone</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </section>

</section>

        </main><footer class="footer">
    <div class="container">
        <div class="columns has-text-centered">
            
            <div class="column is-narrow">
                <a href="/privacy" class="">Privacy</a>
            </div>
            
        </div>
    </div>
</footer></body>
</html>
