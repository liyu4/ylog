<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>aliasliyu4  | [GO]web中间件(2)</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.63.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.1cb140d8ba31d5b2f1114537dd04802a.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="[GO]web中间件(2)" />
<meta property="og:description" content="书接上文" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/how-to-implementation-middleware-using-golang-part2/" />
<meta property="article:published_time" content="2020-02-25T11:48:49+08:00" />
<meta property="article:modified_time" content="2020-02-25T11:48:49+08:00" />
<meta itemprop="name" content="[GO]web中间件(2)">
<meta itemprop="description" content="书接上文">
<meta itemprop="datePublished" content="2020-02-25T11:48:49&#43;08:00" />
<meta itemprop="dateModified" content="2020-02-25T11:48:49&#43;08:00" />
<meta itemprop="wordCount" content="326">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[GO]web中间件(2)"/>
<meta name="twitter:description" content="书接上文"/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      aliasliyu4
    </a>
    <div class="flex-l items-center">
      

      
      














    </div>
  </div>
</nav>

    </div>
  </header>


    <main class="pb7" role="main">
      
  <div class="flex-l mt2 mw8 center">
    <article class="center cf pv5 ph3 ph4-ns mw7">
      <header>
        <p class="f6 b helvetica tracked">
          
        </p>
        <h1 class="f1">
          [GO]web中间件(2)
        </h1>
      </header>
      <div class="nested-copy-line-height lh-copy f4 nested-links nested-img mid-gray">
        <p>书接上文</p>
<h5 id="定义属于你的myhandler接口-任何实现其servehttp方法的类型都可以当作是myhandler">定义属于你的MyHandler接口, 任何实现其ServeHTTP方法的类型都可以当作是MyHandler。</h5>
<pre><code>type MyHandler interface {
	ServeHTTP(w http.ResponserWriter, r *http.Request, next http.HandlerFunc) 
}
next是下一个需要执行的http Handler，它作为一个参数被传递进去。
</code></pre><h5 id="仿照nethttp定义一个函数类型myhandlerfunc-实现servehttp方法">仿照net/http定义一个函数类型MyHandlerFunc, 实现ServeHTTP方法。</h5>
<pre><code>type MyHandlerFunc func (w http.ResponseWriter, r *http.Request, next http.HandlerFunc)

func (h MyHandlerFunc) ServeHTTP(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
	h(w, r, next) // 调用ServeHTTP就是执行具体的MyHandlerFunc, 需要手动执行next函数
}
</code></pre><h5 id="定义一个中间件middleware-middlerware的数据结构像是一个单向链表可以包裹n个前置服务也可以将需要执行的逻辑放在最后的位置">定义一个中间件middleware， middlerware的数据结构像是一个单向链表，可以包裹n个前置服务，也可以将需要执行的逻辑放在最后的位置。</h5>
<pre><code>type middleware struct {
	handler MyHandler // 当前Handler
	next middleware   // 下一个需要执行的middleware
}

// 实现ServeHTTP方法,也就是实现了http Handler.
func (m *middlerware) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// m.next.ServeHTTP 自己调用自己，可以理解成进入下一个middleware
	m.handler.ServeHTTP(w, r, m.next.ServeHTTP) 
}
</code></pre><p>如上，midllerware就是一个Handler, 可在mux中注册，我们举个例子:</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;net/http&quot;
)

type MyHandler interface {
	ServeHTTP(w http.ResponseWriter, r *http.Request, next http.HandlerFunc)
}

type MyHandlerFunc func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc)

func (h MyHandlerFunc) ServeHTTP(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
	h(w, r, next) // 调用ServerHTTP就是执行具体的MyHandlerFunc, 需要手动执行next函数
}

type middleware struct {
	handler MyHandler   // 当前Handler
	next    *middleware // 下一个需要执行的middleware
}

// 实现ServeHTTP方法,也就是实现了http Handler.
func (m middleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// m.next.ServeHTTP 自己调用自己，可以理解成进入下一个middleware
	m.handler.ServeHTTP(w, r, m.next.ServeHTTP)
}

func build(myHandlers []MyHandler) middleware {
	var next middleware

	if len(myHandlers) == 0 {
		return voidMiddleware()
	} else if len(myHandlers) &gt; 1 {
		next = build(myHandlers[1:])
	} else {
		next = voidMiddleware()
	}

	return middleware{myHandlers[0], &amp;next}
}

func voidMiddleware() middleware {
	return middleware{
		MyHandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {}),
		&amp;middleware{},
	}
}

var myHandlerOne = MyHandlerFunc(func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
	fmt.Println(&quot;use myHandlerOne&quot;)
	next(w, r)
})

var myHandlerTwo = MyHandlerFunc(func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
	fmt.Println(&quot;use myHandlerTwo&quot;)
	next(w, r)
})

var loveFunc = func(w http.ResponseWriter, r *http.Request) {
	fmt.Println(&quot;you come you see&quot;)
	w.Write([]byte(&quot;i love golang&quot;))
}

func get(handler http.HandlerFunc) MyHandlerFunc {
	return func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
		handler.ServeHTTP(w, r) // http.HandlerFunc实际调用f(w, r)
		next(w, r)              // 后面执行的handler,当然你也写成next.ServeHTTP(w, r),这和next(w, r)本质是一样的
	}
}

func main() {
	myHandlers := []MyHandler{myHandlerOne, myHandlerTwo, get(loveFunc)}
	m := build(myHandlers)
	mux := http.NewServeMux()
	mux.Handle(&quot;/youqu&quot;, m)
	http.ListenAndServe(&quot;:1234&quot;, mux)
}

</code></pre><h5 id="看看效果">看看效果</h5>
<p><img src="http://ww1.sinaimg.cn/large/9b6074eegy1fvpcqu6vafj21s40cq102.jpg" alt=""></p>
<h4 id="为什么要手动执行一下nextw-r">为什么要手动执行一下next(w, r)</h4>
<p>显然我们看到myHandlerTwo，myHandlerTwo在函数的结尾处调用next(w, r), 其传参数为m.next.ServeHTTP,其本身为函数类型即：func, m.handler.ServeHTTP(w, r, m.next.ServeHTTP), 这里做了匿名转换，将其转换为http.HandlerFunc, 当然显示的转换是更加容易理解的， m.handler.ServeHTTP(w, r, http.HandlerFunc(m.next.ServeHTTP))。 当我们执行next(w, r)的时候其实执行就是m.next.ServeHTTP(w, r), 由此可见，中间件才能往下执行。</p>
<h4 id="总结">总结</h4>
<p>灵魂在于ServeHTTP函数和Handler接口，一个请求进来会调用ServeHTTP, 然后找到对应的handler, 对应下图的handle（w, req, ps）
<img src="http://ww1.sinaimg.cn/large/9b6074eegy1fvpcjt25d8j21dq0f2dlu.jpg" alt="">
handle如何执行呢？ 他会调用Handler的ServeHTTP, 在我们的例子里就是middlerware的ServeHTTP.
<img src="http://ww1.sinaimg.cn/large/9b6074eegy1fvpcm4omj6j21a60cu79w.jpg" alt=""></p>
<p>大概中间件就是这样运行起来的, 如果你完全懂了，那就可以实战了。</p>
<p>完结。</p>
      </div>
    </article>
  </div>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="/" >
    &copy;  aliasliyu4 2020 
  </a>
    <div>













</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
